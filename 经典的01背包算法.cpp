

开心的金明
时空限制 1000ms / 65MB
题目描述
金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 NN 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 NN 元。于是，他把每件物品规定了一个重要度，分为 55 等：用整数 1-51−5 表示，第 55 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 NN 元（可以等于 NN 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
设第 jj 件物品的价格为 v_[j]v [ j] ，重要度为 w_[j]w [ j] ，共选中了 kk 件物品，编号依次为 j_1,j_2,…,j_kj 1 ,j 2 ,…,j k，则所求的总和为：
v[j1]* w[j1]+v[j2]*w[j2]+ …+v[jk]*w[jk]+v[j1]×w[j1]+v [j2]×w [j2]+…+v[jk]×w[jk] 。
请你帮助金明设计一个满足要求的购物单。
输入输出格式
输入格式：
第一行，为 22 个正整数，用一个空格隔开： N mNm （其中 N(<30000)N(<30000) 表示总钱数， m(<25)m(<25) 为希望购买物品的个数。）
从第 22 行到第 m+1m+1 行，第 jj 行给出了编号为 j-1j−1 的物品的基本数据，每行有 22 个非负整数 v pvp （其中 vv 表示该物品的价格 (v \le 10000)(v≤10000) ， pp 表示该物品的重要度( 1-51−5 )
输出格式：
11 个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值 (<100000000)(<100000000) 。
输入输出样例
输入样例#1：

1000 5
800 2
400 5
300 5
400 3
200 2

输出样例#1：

3900
————————————————
版权声明：本文为CSDN博主「密码锁」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42995099/article/details/81986712

// #_------------------------------------------------------------------->

#include<bits/stdc++.h>
#define ll long long
#define fo(i,j,n) for(register int i=j; i<=n; i++)
using namespace std;
const int maxn = 30005;
int n,m,v[maxn],w[maxn],f[maxn];
void get_zero_one(){
	fo(i,1,m){ // 物品
		for(int j=n; j>0; j--){ //钱
			if(j-v[i]>=0)f[j] = max(f[j], f[j-v[i]]+v[i]*w[i]);
		}
	}
	cout<<f[n];
}
int main(){
	scanf("%d%d",&n,&m);
	fo(i,1,m)scanf("%d%d",&v[i],&w[i]);
	get_zero_one();
	return 0;
}
